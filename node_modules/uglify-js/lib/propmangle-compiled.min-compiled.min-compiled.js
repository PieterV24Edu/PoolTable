"use strict";
function find_builtins() {
  var a = [];[Object, Array, Function, Number, String, Boolean, Error, Math, Date, RegExp].forEach(function (ctor) {
    Object.getOwnPropertyNames(ctor).map(add);if (ctor.prototype) {
      Object.getOwnPropertyNames(ctor.prototype).map(add);
    }
  });function add(name) {
    push_uniq(a, name);
  }return a;
}function mangle_properties(ast, options) {
  options = defaults(options, { reserved: null, cache: null, only_cache: false, regex: null, ignore_quoted: false });var reserved = options.reserved;if (reserved == null) reserved = find_builtins();var cache = options.cache;if (cache == null) {
    cache = { cname: -1, props: new Dictionary() };
  }var regex = options.regex;var ignore_quoted = options.ignore_quoted;var names_to_mangle = [];var unmangleable = [];var ignored = {};ast.walk(new TreeWalker(function (node) {
    if (node instanceof AST_ObjectKeyVal) {
      add(node.key, ignore_quoted && node.quote);
    } else if (node instanceof AST_ObjectProperty) {
      add(node.key.name);
    } else if (node instanceof AST_Dot) {
      add(node.property);
    } else if (node instanceof AST_Sub) {
      addStrings(node.property, ignore_quoted);
    }
  }));return ast.transform(new TreeTransformer(function (node) {
    if (node instanceof AST_ObjectKeyVal) {
      if (!(ignore_quoted && node.quote)) node.key = mangle(node.key);
    } else if (node instanceof AST_ObjectProperty) {
      node.key.name = mangle(node.key.name);
    } else if (node instanceof AST_Dot) {
      node.property = mangle(node.property);
    } else if (node instanceof AST_Sub) {
      if (!ignore_quoted) node.property = mangleStrings(node.property);
    }
  }));function can_mangle(name) {
    if (unmangleable.indexOf(name) >= 0) return false;if (reserved.indexOf(name) >= 0) return false;if (options.only_cache) {
      return cache.props.has(name);
    }if (/^[0-9.]+$/.test(name)) return false;return true;
  }function should_mangle(name) {
    if (ignore_quoted && name in ignored) return false;if (regex && !regex.test(name)) return false;if (reserved.indexOf(name) >= 0) return false;return cache.props.has(name) || names_to_mangle.indexOf(name) >= 0;
  }function add(name, ignore) {
    if (ignore) {
      ignored[name] = true;return;
    }if (can_mangle(name)) push_uniq(names_to_mangle, name);if (!should_mangle(name)) {
      push_uniq(unmangleable, name);
    }
  }function mangle(name) {
    if (!should_mangle(name)) {
      return name;
    }var mangled = cache.props.get(name);if (!mangled) {
      do {
        mangled = base54(++cache.cname);
      } while (!can_mangle(mangled));cache.props.set(name, mangled);
    }return mangled;
  }function addStrings(node, ignore) {
    var out = {};try {
      (function walk(node) {
        node.walk(new TreeWalker(function (node) {
          if (node instanceof AST_Seq) {
            walk(node.cdr);return true;
          }if (node instanceof AST_String) {
            add(node.value, ignore);return true;
          }if (node instanceof AST_Conditional) {
            walk(node.consequent);walk(node.alternative);return true;
          }throw out;
        }));
      })(node);
    } catch (ex) {
      if (ex !== out) throw ex;
    }
  }function mangleStrings(node) {
    return node.transform(new TreeTransformer(function (node) {
      if (node instanceof AST_Seq) {
        node.cdr = mangleStrings(node.cdr);
      } else if (node instanceof AST_String) {
        node.value = mangle(node.value);
      } else if (node instanceof AST_Conditional) {
        node.consequent = mangleStrings(node.consequent);node.alternative = mangleStrings(node.alternative);
      }return node;
    }));
  }
}

//# sourceMappingURL=propmangle-compiled.min-compiled.min-compiled.js.map